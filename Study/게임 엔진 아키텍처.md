# 게임 엔진 아키텍처를 읽고 깨달은 것

## 2부

### 5장

1. 게임 매니저 객체  
게임 엔진에 존재하는 다양한 매니저들은 서로 의존성을 가지고 있기에, 생성과, 파괴의 순서가 보장되어야 한다. 그러나, C++의 생성자와 소멸자는 단순한 Singleton을 이용할 시, 그 순서가 보장되지 않는다. 그렇기에 'Init()', 'Shutdown()' 같은 함수를 만들어서 순서를 보장하는 것이 좋다. (한 발짝 더 나아가서, 모든 매니저의 부모가 되는 클래스나, 인터페이스를 만드는 것도 좋은 방법일 것 같다.)  
매니저를 관리하는 클래스를 만드는 것도 좋은 방법이다. 매니저들은 자신의 정보와, 다른 매니저에 대한 의존 관계를 입력하게 하고 (이 역시 매니저 부모 클래스를 이용할 수 있을 것 같다.), 초기화 시에 매니저 관리 클래스는 선행 초기화 작업을 한 후에, 매니저들 간의 의존성 그래프를 만든다. 그 후에 의존성 그래프를 검사해서 (DFS 알고리즘을 활용하면 될 것 같다.) 매니저 생성 큐를 만든다. 이제 매니저 생성 큐의 순서를 따라 매니저를 생성하고, 그 순서를 반대로 하여 파괴 하면 된다.  

2. 메모리 할당자  

* 동적 메모리의 할당은 굉장히 느린 작업이다. 그러므로 게임 엔진에서는 직접 할당자를 제작하여 쓴다. 이렇게 하면 미리 할당된 메모리 블록을 이용할 수 있고, 컨텍스트를 전환할 필요가 없어 빠른 할당을 할 수가 있다. 대표적인 할당자로는 스택 기반 할당자와 풀 할당자가 있다.  

* 메모리 할당자는 정렬된 메모리를 반환할 수 있어야한다. 방법은 간단하다. 정렬 조건 크기 + 요청 크기만큼을 할당한 후에, 시작주소가 정렬된 주소가 되도록 조정하여 반환하면 된다. 조정 값은 처음 메모리 주소에서 가장 낮은 비트를 마스킹한 후에 정렬 조건에서 빼면 된다. 마스크는 정렬 조건에서 1을 빼면 얻을 수 있다. (정렬 조건이 항상 2의 제곱임을 이용) 결론적으로 정렬된 주소를 얻는 수식은 다음과 같다.  
**정렬된 주소 = 주소 + (정렬 조건 - (주소 & (정렬 조건 - 1)))**

* 그렇다면 정렬한 메모리는 어떻게 해제할 수 있을까? 메모리를 해제하기 위해서는 원래 주소를 얻어낼 필요가 있다. 그 방법은 간단하다. 바로 정렬을 위해서 추가로 할당한 메모리에 메타 정보를 저장하는 것이다. 주소를 정렬하면 최소 1바이트는 정렬하게 된다. 그리고 메타 정보는 1바이트면 충분하다 (조정 값이 256을 넘을 수가 없기 때문이다.). 그렇기에 정렬된 주소보다 1바이트 앞에 메타 정보를 저장한다면, 쉽게 읽고 쓸 수 있을 것이다.  

* 게임 루프 중에 임시 데이터 할당이 필요할 때가 있다. 이를 위해 단일 프레임 할당자를 만들 수 있다. 스택 할당자로 구성된 단일 프레임 할당자는 매 프레임마다 할당자를 초기화하는 방식을 통해서 해제를 신경 쓰지 않으면서도 굉장히 빠르게 할당 받을 수 있다. 그러나 한 프레임에만 유지된다는 단점이 존재한다. 이를 보완하는 방법은 간단하다. 단일 프레임 할당자를 2개 만들어서, 매 프레임마다 사용하는 할당자를 교체하는 것이다. 이 방식을 사용하는 할당자를 이중 버퍼 메모리 할당자라고 한다. 이를 활용하면 다음 프레임에 현재 프레임에서 한 작업의 결과를 얻을 수 있으면서도 단일 프레임 할당자의 이점을 그대로 챙길 수 있다.  
