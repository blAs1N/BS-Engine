# 게임 엔진 아키텍처를 읽고 깨달은 것

## 2부

### 5장

1. 게임 매니저 객체  
게임 엔진에 존재하는 다양한 매니저들은 서로 의존성을 가지고 있기에, 생성과, 파괴의 순서가 보장되어야 한다. 그러나, C++의 생성자와 소멸자는 단순한 Singleton을 이용할 시, 그 순서가 보장되지 않는다. 그렇기에 'Init()', 'Shutdown()' 같은 함수를 만들어서 순서를 보장하는 것이 좋다. (한 발짝 더 나아가서, 모든 매니저의 부모가 되는 클래스나, 인터페이스를 만드는 것도 좋은 방법일 것 같다.)  
매니저를 관리하는 클래스를 만드는 것도 좋은 방법이다. 매니저들은 자신의 정보와, 다른 매니저에 대한 의존 관계를 입력하게 하고 (이 역시 매니저 부모 클래스를 이용할 수 있을 것 같다.), 초기화 시에 매니저 관리 클래스는 선행 초기화 작업을 한 후에, 매니저들 간의 의존성 그래프를 만든다. 그 후에 의존성 그래프를 검사해서 (DFS 알고리즘을 활용하면 될 것 같다.) 매니저 생성 큐를 만든다. 이제 매니저 생성 큐의 순서를 따라 매니저를 생성하고, 그 순서를 반대로 하여 파괴 하면 된다.  

2. 메모리 할당자  

* 메모리 할당자는 정렬된 메모리를 반환할 수 있어야한다. 방법은 간단하다. 정렬 조건 크기 + 요청 크기만큼을 할당한 후에, 시작주소가 정렬된 주소가 되도록 조정하여 반환하면 된다. 조정 값은 처음 메모리 주소에서 가장 낮은 비트를 마스킹한 후에 정렬 조건에서 빼면 된다. 마스크는 정렬 조건에서 1을 빼면 얻을 수 있다. (정렬 조건이 항상 2의 제곱임을 이용) 결론적으로 정렬된 주소를 얻는 수식은 다음과 같다.  
**정렬된 주소 = 주소 + (정렬 조건 - (주소 & (정렬 조건 - 1)))**
