# 게임 엔진 아키텍처를 읽고 깨달은 것

## 2부

### 5장

1. 게임 매니저 객체  
게임 엔진에 존재하는 다양한 매니저들은 서로 의존성을 가지고 있기에, 생성과, 파괴의 순서가 보장되어야 한다. 그러나, C++의 생성자와 소멸자는 단순한 Singleton을 이용할 시, 그 순서가 보장되지 않는다. 그렇기에 'Init()', 'Shutdown()' 같은 함수를 만들어서 순서를 보장하는 것이 좋다. (한 발짝 더 나아가서, 모든 매니저의 부모가 되는 클래스나, 인터페이스를 만드는 것도 좋은 방법일 것 같다.)  
매니저를 관리하는 클래스를 만드는 것도 좋은 방법이다. 매니저들은 자신의 정보와, 다른 매니저에 대한 의존 관계를 입력하게 하고 (이 역시 매니저 부모 클래스를 이용할 수 있을 것 같다.), 초기화 시에 매니저 관리 클래스는 선행 초기화 작업을 한 후에, 매니저들 간의 의존성 그래프를 만든다. 그 후에 의존성 그래프를 검사해서 (DFS 알고리즘을 활용하면 될 것 같다.) 매니저 생성 큐를 만든다. 이제 매니저 생성 큐의 순서를 따라 매니저를 생성하고, 그 순서를 반대로 하여 파괴 하면 된다.  

2. 메모리 할당자  

* 동적 메모리의 할당은 굉장히 느린 작업이다. 그러므로 게임 엔진에서는 직접 할당자를 제작하여 쓴다. 이렇게 하면 미리 할당된 메모리 블록을 이용할 수 있고, 컨텍스트를 전환할 필요가 없어 빠른 할당을 할 수가 있다. 대표적인 할당자로는 스택 기반 할당자와 풀 할당자가 있다.  

* 메모리 할당자는 정렬된 메모리를 반환할 수 있어야한다. 방법은 간단하다. 정렬 조건 크기 + 요청 크기만큼을 할당한 후에, 시작주소가 정렬된 주소가 되도록 조정하여 반환하면 된다. 조정 값은 처음 메모리 주소에서 가장 낮은 비트를 마스킹한 후에 정렬 조건에서 빼면 된다. 마스크는 정렬 조건에서 1을 빼면 얻을 수 있다. (정렬 조건이 항상 2의 제곱임을 이용) 결론적으로 정렬된 주소를 얻는 수식은 다음과 같다.  
**정렬된 주소 = 주소 + (정렬 조건 - (주소 & (정렬 조건 - 1)))**

* 그렇다면 정렬한 메모리는 어떻게 해제할 수 있을까? 메모리를 해제하기 위해서는 원래 주소를 얻어낼 필요가 있다. 그 방법은 간단하다. 바로 정렬을 위해서 추가로 할당한 메모리에 메타 정보를 저장하는 것이다. 주소를 정렬하면 최소 1바이트는 정렬하게 된다. 그리고 메타 정보는 1바이트면 충분하다 (조정 값이 256을 넘을 수가 없기 때문이다.). 그렇기에 정렬된 주소보다 1바이트 앞에 메타 정보를 저장한다면, 쉽게 읽고 쓸 수 있을 것이다.  

* 게임 루프 중에 임시 데이터 할당이 필요할 때가 있다. 이를 위해 단일 프레임 할당자를 만들 수 있다. 스택 할당자로 구성된 단일 프레임 할당자는 매 프레임마다 할당자를 초기화하는 방식을 통해서 해제를 신경 쓰지 않으면서도 굉장히 빠르게 할당 받을 수 있다. 그러나 한 프레임에만 유지된다는 단점이 존재한다. 이를 보완하는 방법은 간단하다. 단일 프레임 할당자를 2개 만들어서, 매 프레임마다 사용하는 할당자를 교체하는 것이다. 이 방식을 사용하는 할당자를 이중 버퍼 메모리 할당자라고 한다. 이를 활용하면 다음 프레임에 현재 프레임에서 한 작업의 결과를 얻을 수 있으면서도 단일 프레임 할당자의 이점을 그대로 챙길 수 있다.  

* 크기가 다른 객체를 순서 없이 할당과 해제를 반복하면 메모리 단편화가 일어난다. (만약 크기가 일정하다면 풀 할당자를, 순서가 정해져있다면 스택 할당자를 고려하자.) 단편화를 해결하기 위해서는 조각 모음을 해야하는데, 할당된 블록을 가르키는 포인터들이 있다면, 이 포인터들을 모두 찾아서 새로운 주소를 가르키게 해야한다. 그러나 특정 지역을 가르키는 포인터를 찾는 작업은 어려운 작업이다. 그러므로 재배치에 적합한 스마트 포인터나, 핸들을 쓰는 것이 적합하다.

* 캐시 메모리는 실행 파일의 명령어 코드가 실행 되기 전 불러오는 데 쓰이는 명령어 캐시 (I 캐시)와, 데이터를 메인 RAM에 읽고 쓰는 속도를 빠르게 하는 데이터 캐시 (D 캐시)로 나뉜다. 이 두 캐시는 물리적으로 분리 되어있기에, I 캐시 미스와 D 캐시 미스 모두 프로그램을 느리게 할 수 있다.

* I 캐시 미스를 피하는 방법은 다음과 같다.

  * 성능이 중요한 코드는 가능한 기계어 명령어 수가 적게 짜야 한다.

  * 성능에 큰 영향을 미치는 코드에서는 함수 호출을 자제해야 한다.
  
  * 같은 번역 단위에 있는 함수들은 선언되는 순서대로 함수들이 메모리에 배열되기에, 호출해야 하는 함수를 현재 함수와 가까운 곳에 배치해야 한다. 다른 번역 단위에 있는 함수일 경우, 기계어 거리를 보장할 수 없다.

  * 작은 함수를 인라인 함수로 하면, 성능을 향상 시킬 수 있으나, 인라인 함수가 크다면 코드의 크기가 커져 코드가 캐시에 다 들어갈 수 없게 될 수 있으므로, 주의해야 한다.

* 후위 연산자 대신 전위 연산자를 사용하는 것도 중요한 최적화 기법이다. 전위 연산자는 연산을 끝내고 피연산자의 값을 반환하기만 하면 된다. 그러나 후위 연산자는 연산 전 값을 저장한 후, 연산 후에, 저장한 값을 반환해야한다. 결국 새 것을 생성하고 복사하는 시간이 추가로 소모된다.
